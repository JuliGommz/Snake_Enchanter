# Working Methodology Standards

**Version**: 1.0  
**Purpose**: Systematic process framework for all development activities  
**Application**: Throughout entire development lifecycle  
**Dependencies**: References QUALITY_VERIFICATION_STANDARDS.md for gates

---

## ðŸ”„ CORE WORKING PRINCIPLES

### One-Step-at-a-Time Methodology

**Definition**: Complete one task fully before starting the next

**Rationale**:
- ADHD-optimized workflow
- Reduces cognitive load
- Prevents scope creep
- Ensures quality completion

**Application**:
```
Sequential Process:
1. Identify single task
2. Complete task fully
3. Validate completion
4. Document outcome
5. Move to next task

NOT Parallel:
âŒ Starting multiple tasks simultaneously
âŒ Switching between incomplete tasks
âŒ "Quick fixes" while working on main task
```

**Example**:
```
âœ“ CORRECT:
  Task 1: Implement player movement â†’ COMPLETE â†’ Test â†’ Document
  Task 2: Add jump mechanic â†’ COMPLETE â†’ Test â†’ Document
  Task 3: Integrate camera follow â†’ COMPLETE â†’ Test â†’ Document

âœ— WRONG:
  Start movement â†’ Start jump â†’ Start camera â†’ Debug all together
```

---

### One Change Type Per Iteration

**Critical Rule**: Separate different types of changes completely

**Change Type Categories**:
```
Input System Changes
  â†’ New Input System integration
  â†’ Control remapping
  â†’ Input validation

Performance Optimization
  â†’ Object pooling
  â†’ LOD implementation
  â†’ Garbage collection reduction

Architecture Refactoring
  â†’ Pattern implementation
  â†’ Service extraction
  â†’ Component reorganization

Feature Implementation
  â†’ New gameplay mechanics
  â†’ UI additions
  â†’ Content integration

Bug Fixes
  â†’ Error corrections
  â†’ Edge case handling
  â†’ Workaround removal
```

**Why This Matters**:
```
âœ“ Easier debugging (know what caused issue)
âœ“ Safer rollback (single change to revert)
âœ“ Clearer testing (validate one thing)
âœ“ Better documentation (focused commits)
```

**Example**:
```
âœ“ CORRECT (separate iterations):
  Iteration 1: Migrate to New Input System
  Iteration 2: Optimize Update() loops
  Iteration 3: Refactor to Service Pattern

âœ— WRONG (combined):
  One iteration: Input migration + optimization + refactoring
  â†’ Which change broke it? Unknown.
```

---

### Incremental Boundary Enforcement

**Definition**: Maintain strict separation between concerns

**Boundaries**:
```
System Boundaries:
  Input â‰  Rendering â‰  Physics â‰  Audio â‰  UI

Layer Boundaries:
  Data â‰  Logic â‰  Presentation

Phase Boundaries:
  Design â‰  Implementation â‰  Testing â‰  Documentation
```

**Enforcement**:
```
When working on Input:
  â†’ Only touch input-related code
  â†’ Don't "fix" unrelated rendering issues
  â†’ Don't add features while debugging

When refactoring architecture:
  â†’ Don't add new features
  â†’ Don't optimize performance
  â†’ Focus solely on structure
```

---

## ðŸ› ï¸ PROBLEM RESOLUTION PROTOCOL

### Four-Phase Systematic Approach

**Phase 1: Problem Isolation + Full Analysis**
```
Objective: Complete system understanding before ANY changes

Steps:
1. Reproduce issue consistently
2. Identify exact failure point
3. Trace dependencies
4. Document system state
5. Analyze recent changes
6. Review relevant documentation

Questions to Answer:
  - What exactly is failing?
  - When did it start failing?
  - What changed before failure?
  - What does working look like?
  - What are dependencies?

Output: Written problem description with context
```

**Phase 2: Baseline Recovery**
```
Objective: Return to last known working state

Steps:
1. Locate last working version
2. Verify it actually works
3. Document functional baseline
4. Preserve current state (branch/backup)
5. Restore baseline as working foundation

Critical: 
  â†’ Working system takes precedence over broken "improvements"
  â†’ Security > Sophistication
  â†’ Stability > New features
```

**Phase 3: Targeted Fix**
```
Objective: Minimal invasive change to resolve issue

Steps:
1. Identify SMALLEST possible fix
2. Change ONE thing
3. Test immediately
4. Verify no side effects
5. Document what was changed and why

Constraints:
  â†’ Preserve all working functionality
  â†’ No "while I'm here" additional changes
  â†’ No refactoring during bug fixing
```

**Phase 4: Complete Validation**
```
Objective: Ensure fix doesn't break anything else

Steps:
1. Test fixed functionality
2. Test related systems
3. Check for regressions
4. Verify performance unchanged
5. Console error check
6. Integration test full workflow

Quality Gates:
  [ ] Original issue resolved
  [ ] No new issues introduced
  [ ] All existing features still work
  [ ] Performance maintained
  [ ] Documentation updated
```

---

### Original Baseline Recovery Pattern

**When to Use**: Regression detected during iteration

**Protocol**:
```
1. STOP all forward progress immediately
2. Document current broken state
3. Identify last known-good state
4. Restore baseline version
5. Verify baseline works
6. Work from stable foundation

Never: "Try to fix forward" when broken
Always: "Return to working, then proceed carefully"
```

**Example**:
```
Scenario: Input refactoring broke player movement

âœ“ CORRECT:
  1. Stop refactoring
  2. Git revert to working version
  3. Verify movement works
  4. Identify what broke it
  5. Make smaller, safer change

âœ— WRONG:
  1. Keep trying different fixes
  2. Add more changes to "fix" it
  3. Debug without stable baseline
```

---

## ðŸ“‹ QUALITY GATE SYSTEM

### Phase-Adaptive Quality Gates

**Concept Phase Gates**:
```
[ ] Design consistency validated
[ ] Academic documentation started
[ ] Feasibility confirmed
[ ] Requirements clear
[ ] Scope defined
[ ] Resources identified
```

**Development Phase Gates**:
```
[ ] Code compiles without errors
[ ] Functional testing passed
[ ] Attribution headers present
[ ] Component-First methodology followed
[ ] No Unicode symbols in code
[ ] Console clear of errors
[ ] Unit tests pass (if applicable)
```

**Integration Phase Gates**:
```
[ ] Unity project stable / Website loads
[ ] Component dependencies satisfied
[ ] Error-free console
[ ] Cross-system integration tested
[ ] Performance acceptable
[ ] No regressions detected
```

**Content Phase Gates**:
```
[ ] Asset quality meets standards
[ ] Import successful
[ ] Performance validation passed
[ ] Attribution documented
[ ] Licensing verified
```

**Submission Phase Gates**:
```
[ ] Complete documentation present
[ ] Academic compliance verified
[ ] Final testing passed
[ ] README accurate
[ ] Known issues documented
[ ] Third-party credits complete
[ ] Submission checklist complete
```

---

### Error Prevention Automation

**Pre-Development Checks**:
```
Before writing ANY code:
  [ ] Requirements validated
  [ ] Scope verified
  [ ] Resources confirmed
  [ ] Dependencies identified
  [ ] Components exist (Component-First)
  [ ] Architecture designed
```

**During Development Checks**:
```
After each significant change:
  [ ] Code compiles
  [ ] Tests pass (if applicable)
  [ ] Console clean
  [ ] Functionality preserved
  [ ] Performance acceptable
```

**Integration Checks**:
```
Before merging/committing:
  [ ] Components validated
  [ ] References assigned
  [ ] Unity-specific checks passed (if applicable)
  [ ] Full integration test
  [ ] Regression test passed
```

---

## ðŸŽ¯ PRIORITY HIERARCHY

**When Conflicts Arise, Follow This Order**:

```
1. FUNCTIONALITY
   â†’ Working system takes absolute precedence
   â†’ No breaking changes without explicit approval
   â†’ Preserve baseline above all else

2. USER TRUST
   â†’ Reliable behavior over new features
   â†’ Predictable results over clever solutions
   â†’ Transparency over hidden complexity

3. PERFORMANCE
   â†’ Optimize after functionality proven
   â†’ Measure before optimizing
   â†’ Profile-driven optimization only

4. ELEGANCE
   â†’ Clean code after stability achieved
   â†’ Refactor from working state
   â†’ Improve without breaking

5. INNOVATION
   â†’ New patterns only after validation
   â†’ Experimental features isolated
   â†’ Fall back if unstable
```

**Example Decision**:
```
Situation: Elegant solution available but unproven vs. simple working solution

Decision: Choose simple working solution
Rationale: Functionality (Priority 1) > Elegance (Priority 4)
```

---

## ðŸ”§ TROUBLESHOOTING PROTOCOL

### Context-Before-Code Principle

**When User Reports Issues**:
```
NEVER: Immediately suggest code changes

ALWAYS:
1. Request complete context
2. Ask to see current setup
3. Validate understanding
4. THEN propose solution

Questions to Ask:
  - "Show me your current configuration"
  - "What components exist in the scene/DOM?"
  - "What was the last thing that worked?"
  - "What changed since then?"
  - "Can you share the error message?"
```

---

### Minimal Invasive Approach

**When Uncertainty Exists**:
```
Principle: Smallest possible change

Process:
1. Identify minimal change needed
2. Make ONLY that change
3. Test immediately
4. Verify no side effects
5. Proceed if successful
6. Rollback if issues

Never: "Might as well also fix/improve X while here"
Always: "Change one thing, test, validate, proceed"
```

**Example**:
```
Issue: Button not responding

âœ“ MINIMAL:
  1. Check button event listener exists
  2. If missing, add listener
  3. Test
  4. Done

âœ— INVASIVE:
  1. Rewrite entire button system
  2. Add new event handling framework
  3. Refactor related components
  4. Debug complex new code
```

---

### User Anxiety Response

**Recognizing User Anxiety Signals**:
```
Phrases like:
  - "I'm afraid to change..."
  - "It's working, I don't want to break it"
  - "Everything is carefully commented"
  - "I'm nervous about modifying..."
```

**Response Protocol**:
```
1. Acknowledge concern (validate feeling)
2. Propose minimal invasive approach
3. Explain safety measures
4. Offer backup strategy
5. Proceed cautiously
6. Test thoroughly

Never: Dismiss concern or push aggressive changes
Always: Security > Sophistication
```

---

## ðŸ“Š WORKFLOW OPTIMIZATION

### Session Continuity Protocol

**New Session/Topic Change**:
```
1. Query Last Known State
   â†’ "What was the last thing we completed?"
   â†’ "Where did we leave off?"
   â†’ "What's the current status?"

2. Provide Mini-Recap
   â†’ Summarize current understanding
   â†’ List recent changes
   â†’ Identify next steps

3. Confirm Accuracy
   â†’ User validates recap
   â†’ Corrections made if needed
   â†’ Agreement on continuation point

4. Establish Clear Continuation Point
   â†’ Define immediate next task
   â†’ Confirm approach
   â†’ Begin work
```

---

### Progress Documentation

**After Each Significant Milestone**:
```
Document:
  âœ“ What was accomplished
  âœ“ What changed
  âœ“ What works now
  âœ“ What doesn't work yet
  âœ“ Next concrete steps
  âœ“ Known issues/concerns
```

**Update Project Files**:
```
  â†’ CURRENT_PHASE_STATUS.md
  â†’ KNOWN_ISSUES_DECISIONS_LOG.md
  â†’ Architecture docs (if structure changed)
```

---

## âœ… METHODOLOGY CHECKLIST

**Before Starting Work**:
```
[ ] Task clearly defined
[ ] Scope limited (one-step-at-a-time)
[ ] Change type identified (only one type)
[ ] Prerequisites met
[ ] Baseline documented
[ ] Quality gates defined
```

**During Work**:
```
[ ] Single focus maintained
[ ] Incremental progress
[ ] Testing after each change
[ ] Documentation updated
[ ] Console monitored
```

**After Completing Task**:
```
[ ] Full validation passed
[ ] Quality gates met
[ ] Documentation complete
[ ] Next steps clear
[ ] Baseline preserved
```

---

## ðŸ”— INTEGRATION WITH OTHER STANDARDS

**Uses**:
- QUALITY_VERIFICATION_STANDARDS.md for quality gates
- CODE_DEVELOPMENT_STANDARDS.md for implementation rules

**Referenced By**:
- COMMUNICATION_SESSION_STANDARDS.md for interaction patterns

---

**Status**: Active  
**Review Frequency**: Quarterly  
**Owner**: Process governance (all projects)

---
