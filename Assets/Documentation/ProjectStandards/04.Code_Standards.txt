# Code Development Standards

**Version**: 1.0  
**Purpose**: Implementation guidelines for all coding activities  
**Application**: During code writing, reviewing, and refactoring  
**Dependencies**: References QUALITY_VERIFICATION_STANDARDS.md for verification

---

## ðŸŽ¯ CORE DEVELOPMENT PRINCIPLES

### Simplicity over Complexity

**Definition**: Choose the simplest solution that solves the problem effectively

**Application**:
```
âœ“ Avoid enterprise over-engineering patterns
âœ“ Use academic-level appropriate complexity
âœ“ Prefer readable code over clever code
âœ“ Select patterns students can understand and learn from
```

**Examples**:
```
âœ“ SIMPLE: Direct event handlers over custom event bus (small projects)
âœ“ SIMPLE: Plain arrays over custom collection classes (unless needed)
âœ“ SIMPLE: Clear if-else over complex ternary chains

âœ— COMPLEX: Dependency injection frameworks (academic projects)
âœ— COMPLEX: Custom reflection-based systems (over-engineering)
âœ— COMPLEX: Abstract factory pattern (when simple factory suffices)
```

**When Complexity is Justified**:
- Project explicitly requires it (academic learning goal)
- Scale demands it (proven bottleneck)
- Team size requires it (coordination need)
- Reusability proven beneficial (not speculative)

---

### Component-First Methodology

**Critical Rule**: Setup components/elements BEFORE writing scripts

**Mandatorische Sequence**:
```
Phase 1: Analysis
  â†’ Identify all required components
  â†’ List dependencies
  â†’ Plan integration points

Phase 2: Setup
  â†’ Create/configure ALL components FIRST
  â†’ Verify components exist in scene/DOM
  â†’ Configure initial properties

Phase 3: Integration
  â†’ Write scripts referencing components
  â†’ Attach scripts to GameObjects/Elements
  â†’ Add academic attribution headers

Phase 4: Validation
  â†’ Test functionality
  â†’ Verify no null references
  â†’ Check console for errors

Phase 5: Documentation
  â†’ Document component dependencies
  â†’ Record implementation decisions
```

**Why This Matters**:
- Prevents null reference exceptions
- Ensures dependencies exist before use
- Validates architecture before implementation
- Reduces debugging time significantly

**Unity-Specific**:
```
âœ“ CORRECT: 
  1. Create GameObject in scene
  2. Add required components (Rigidbody, Collider, etc.)
  3. Write script referencing components
  4. Attach script to GameObject

âœ— WRONG:
  1. Write script first
  2. Attach to GameObject
  3. Discover missing components via errors
```

**Web-Specific**:
```
âœ“ CORRECT:
  1. Create HTML elements with IDs/classes
  2. Verify DOM structure
  3. Write JavaScript selecting elements
  4. Attach event listeners

âœ— WRONG:
  1. Write JavaScript selecting non-existent elements
  2. Create HTML later
  3. Debug querySelector issues
```

---

### Data/Behavior Separation Pattern

**Principle**: Configuration separate from logic

**Unity Implementation**:
```
ScriptableObject: Data containers
  â†’ Designer-friendly tweaking
  â†’ Reusable configurations
  â†’ No runtime behavior

MonoBehaviour: Runtime behavior
  â†’ Unity lifecycle methods
  â†’ Interaction logic
  â†’ Scene integration

Example:
  EnemyData.cs (ScriptableObject)
    â†’ health, speed, damage values
  
  Enemy.cs (MonoBehaviour)
    â†’ TakeDamage(), Move(), Attack() methods
    â†’ References EnemyData for values
```

**Web Implementation**:
```
Data Layer: Pure data structures
  â†’ JSON configurations
  â†’ Constant definitions
  â†’ Static data arrays

Presentation Layer: Rendering logic
  â†’ DOM manipulation
  â†’ Event handling
  â†’ State management

Example:
  projectData = [ {...} ]  // Data layer
  
  function renderProject(data) { ... }  // Presentation layer
```

**Benefits**:
- Easy content updates (no code changes)
- Testability (data mockable)
- Designer/developer separation
- Open/Closed Principle adherence

---

## ðŸ—ï¸ ARCHITECTURE PATTERNS

### Clean Architecture Principles

**Layer Separation**:
```
Data Layer
  â†’ Pure data structures
  â†’ No business logic
  â†’ Serializable/configurable

Logic Layer
  â†’ Business rules
  â†’ State management
  â†’ Algorithm implementation

Presentation Layer
  â†’ UI/rendering
  â†’ User input handling
  â†’ Visual feedback
```

**Dependency Rule**:
```
â†’ Presentation depends on Logic
â†’ Logic depends on Data
â†’ Never reverse direction
â†’ Data layer has zero dependencies
```

**Unity Example**:
```
Data: ScriptableObjects (item stats, NPC dialogue)
Logic: Service classes (QuestService, InventoryService)
Presentation: MonoBehaviours (UI controllers, player input)
```

**Web Example**:
```
Data: JavaScript objects/arrays (project data, config)
Logic: Pure functions (filterProjects, sortItems)
Presentation: DOM manipulation (renderGallery, updateUI)
```

---

### Service Pattern (When Appropriate)

**Use When**:
- Multiple components need shared functionality
- Cross-cutting concerns exist (audio, persistence)
- Centralized state management needed

**Implementation**:
```
Service Class
  â†’ Singleton or dependency injection
  â†’ Clear public API
  â†’ No direct Unity/DOM dependencies (testability)

Service Locator (optional)
  â†’ Central registry
  â†’ Type-safe service retrieval
  â†’ Lifecycle management
```

**Unity Example**:
```csharp
public class AudioService : MonoBehaviour
{
    private static AudioService _instance;
    public static AudioService Instance => _instance;
    
    void Awake()
    {
        if (_instance != null && _instance != this)
        {
            Destroy(gameObject);
            return;
        }
        _instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    public void PlaySound(AudioClip clip) { ... }
}
```

**Web Example**:
```javascript
const lightboxService = {
    isOpen: false,
    currentIndex: 0,
    
    open(projectId, index) { ... },
    close() { ... },
    navigate(direction) { ... }
};
```

**When NOT to Use**:
- Simple projects (< 5 components)
- No shared state needed
- Over-engineering risk high

---

## ðŸ’» CODE QUALITY STANDARDS

### Naming Conventions

**Variables**:
```
âœ“ Descriptive, clear purpose
âœ“ camelCase (JavaScript, C# fields)
âœ“ Avoid abbreviations (unless standard)

Examples:
  âœ“ playerHealth, currentScore, isGameOver
  âœ— ph, cs, igo
```

**Functions/Methods**:
```
âœ“ Verb-first naming
âœ“ Describes action clearly
âœ“ camelCase (JavaScript, C#)

Examples:
  âœ“ CalculateDamage(), RenderGallery(), OpenModal()
  âœ— Damage(), Gallery(), Modal()
```

**Classes**:
```
âœ“ Noun naming
âœ“ PascalCase
âœ“ Specific, not generic

Examples:
  âœ“ QuestService, PlayerController, LightboxManager
  âœ— Manager, Handler, Helper
```

**Constants**:
```
âœ“ Semantic naming
âœ“ camelCase or SCREAMING_SNAKE_CASE (context-dependent)

Examples:
  âœ“ maxHealth, DEFAULT_SPEED
  âœ“ pillarColors, API_BASE_URL
```

---

### Code Structure

**Method Complexity**:
```
âœ“ Single responsibility per method
âœ“ Aim for < 20 lines per method
âœ“ Extract complex logic to helpers
âœ“ Readable without comments (self-documenting)
```

**File Organization**:
```
File Header
  â†’ Academic attribution
  â†’ Purpose statement
  â†’ Dependencies listed

Imports/Using Statements
  â†’ Grouped logically
  â†’ Alphabetically sorted (optional)

Constants/Configuration
  â†’ Top of file after imports

Class/Module Definition
  â†’ Public API first
  â†’ Private helpers after
```

**Comment Guidelines**:
```
âœ“ Explain WHY, not WHAT (code shows what)
âœ“ Document complex algorithms
âœ“ Mark TODOs explicitly
âœ“ Warn about gotchas/edge cases

âœ— Don't comment obvious code
âœ— Don't leave dead code commented out
âœ— Don't use comments as version control
```

---

### Error Handling

**Defensive Programming**:
```csharp
// Unity Example
if (target == null)
{
    Debug.LogError("Target is null in Attack()");
    return;
}

// Web Example
if (!element) {
    console.error('Element not found:', selector);
    return;
}
```

**Graceful Degradation**:
```javascript
// Fallback values
const thumbnail = project.thumbnail || 
                  (project.gallery?.[0]?.src) || 
                  'placeholder.png';

// Optional functionality
try {
    advancedFeature();
} catch (error) {
    console.warn('Advanced feature unavailable:', error);
    // Continue with basic functionality
}
```

**Validation**:
```
âœ“ Validate inputs at function entry
âœ“ Check array bounds before access
âœ“ Verify dependencies exist before use
âœ“ Log errors with context (not just generic messages)
```

---

## ðŸš« ANTI-PATTERNS (NEVER)

### Compilation Safety

**No Unicode Symbols in Code**:
```
âŒ FORBIDDEN:
    // Check if player is alive âœ“
    const isAlive = health > 0; // âœ… works
    
âœ“ CORRECT:
    // Check if player is alive (valid)
    const isAlive = health > 0; // Works correctly
```

**Reason**: Compilation errors across platforms/editors

---

### Architecture Anti-Patterns

**No Scripts Before Components**:
```
âŒ Writing PlayerController.cs before creating Player GameObject
âŒ Selecting DOM elements before HTML exists
âŒ Referencing services before initialization
```

**No Enterprise Over-Engineering**:
```
âŒ Complex abstract factories for simple object creation
âŒ Reflection-based systems in student projects
âŒ Custom serialization when built-in suffices
âŒ Premature optimization patterns
```

**No Premature Abstraction**:
```
âŒ Creating interfaces with single implementation
âŒ Building frameworks before features
âŒ Abstracting before understanding requirements
```

---

### Code Smell Avoidance

**Avoid**:
```
âŒ God classes (> 500 lines, many responsibilities)
âŒ Magic numbers (unexplained constants)
âŒ Deep nesting (> 3 levels of indentation)
âŒ Long parameter lists (> 4 parameters)
âŒ Duplicate code (DRY principle violation)
```

---

## ðŸ”„ REFACTORING GUIDELINES

### When to Refactor

**Refactor When**:
```
âœ“ Code works but unclear
âœ“ Duplication detected (3+ times)
âœ“ Method too long (> 30 lines)
âœ“ Performance bottleneck proven
âœ“ Adding feature reveals poor structure
```

**Don't Refactor When**:
```
âœ— Code works and deadline approaching
âœ— Not confident in test coverage
âœ— Unclear what improvement looks like
âœ— Refactoring for theoretical future needs
```

---

### Refactoring Protocol

**Safe Refactoring Process**:
```
1. Original_Baseline_Recovery
   â†’ Commit/save working version
   â†’ Document current functionality
   
2. Incremental Changes
   â†’ ONE change type per iteration
   â†’ Test after each change
   â†’ Verify functionality preserved
   
3. Validation
   â†’ All tests pass (if tests exist)
   â†’ Manual testing confirms behavior
   â†’ No console errors
   
4. Documentation
   â†’ Update comments if structure changed
   â†’ Record refactoring decisions
```

---

## ðŸŽ“ ACADEMIC CONTEXT CONSIDERATIONS

### Learning-Appropriate Complexity

**Student Project Standards**:
```
âœ“ Patterns that teach valuable concepts
âœ“ Complexity justified by learning goals
âœ“ Code others can understand and learn from
âœ“ Balance between best practices and simplicity
```

**Avoid**:
```
âœ— Production-grade enterprise patterns
âœ— Clever tricks over clear code
âœ— Frameworks that obscure fundamentals
âœ— Complexity without educational value
```

---

## ðŸ“‹ CODE REVIEW CHECKLIST

**Before Submitting/Committing Code**:
```
[ ] Component-First methodology followed
[ ] No Unicode symbols in code
[ ] Academic attribution header present (new files)
[ ] Naming conventions consistent
[ ] No magic numbers (constants defined)
[ ] Error handling present where needed
[ ] Comments explain WHY, not WHAT
[ ] No enterprise over-engineering
[ ] Simplicity principle honored
[ ] Code compiles without errors
[ ] Console clear of warnings (or documented)
[ ] Functionality tested manually
```

---

## ðŸ”— INTEGRATION WITH OTHER STANDARDS

**References**:
- Uses QUALITY_VERIFICATION_STANDARDS.md for pre-commit validation
- Works with DOCUMENTATION_ATTRIBUTION_STANDARDS.md for headers
- Follows WORKING_METHODOLOGY_STANDARDS.md for process

**Referenced By**:
- WORKING_METHODOLOGY (for implementation phase)
- DOCUMENTATION_ATTRIBUTION (for code commenting)

---

**Status**: Active  
**Review Frequency**: Quarterly or on technology upgrade  
**Owner**: Code implementation standards (all projects)

---

**END OF CODE DEVELOPMENT STANDARDS v1.0**